<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>bcc - 如创科技</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="icon" href="https://www.rutron.net/favicon.png">

  
  
  <link rel="stylesheet" href="/css/style.min.bed369b6636aa19e87512113b3caaa34b9db89c9c071f25efab970ae54757c9c.css">
  

  

</head>

<body class='page '>
  <div id="main-menu-mobile" class="main-menu-mobile">
  <ul>
    
    
    <li class="menu-item-服务">
      <a href="/services/">
        
        <span>服务</span>
      </a>
    </li>
    
    <li class="menu-item-关于">
      <a href="/about/">
        
        <span>关于</span>
      </a>
    </li>
    
    <li class="menu-item-联系">
      <a href="/contact/">
        
        <span>联系</span>
      </a>
    </li>
    
  </ul>
</div>
  <div id="wrapper" class="wrapper">
    <div class='header header-absolute'>
  <div class="container">
    <div class="logo">
      <a href="https://www.rutron.net/"><img height=40px width=40px alt="如创科技" src="/images/logo.png" /></a>
    </div>
    <div class="logo-mobile">
      <a href="https://www.rutron.net/"><img height=40px width=40px alt="如创科技" src="/images/logo.png" /></a>
    </div>
    <div id="main-menu" class="main-menu">
  <ul>
    
    
    <li class="menu-item-服务">
      <a href="/services/">
        
        <span>服务</span>
      </a>
    </li>
    
    <li class="menu-item-关于">
      <a href="/about/">
        
        <span>关于</span>
      </a>
    </li>
    
    <li class="menu-item-联系">
      <a href="/contact/">
        
        <span>联系</span>
      </a>
    </li>
    
  </ul>
</div>
    <button id="toggle-main-menu-mobile" class="hamburger hamburger--slider" type="button" aria-label="Toggle Menu">
  <span class="hamburger-box">
    <span class="hamburger-inner"></span>
  </span>
</button>
  </div>
</div>
    

<div class="container pt-10 pb-6">
  <div class="row">
    <div class="col-12">
      <h1 class="title-1 black">bcc</h1>
      
    </div>
  </div>
</div>

<div class="container pb-6">
  <div class="row">
    
    <div class="col-12 col-md-6 mb-2 "><p>点击查看<a href="https://ebpf.io/what-is-ebpf">原文</a></p>
<h2 id="什么是-ebpf">什么是 eBPF?</h2>
<p>eBPF 是革命性技术, 起源于 linux 内核, 能够在操作系统内核中执行沙盒程序. 旨在不改变内核源码或加载内核模块的前提下安全便捷的扩展内核能力.</p>
<p>历史上, 由于内核拥有全局查看并控制整个操作系统的特权, 操作系统一直被认为是实现可观察性, 安全, 网络功能的理想地方. 同时, 由于其核心角色和对于稳定和安全的高要求, 操作系统很难演进. 因此, 传统上与在操作系统之外实现的功能相比, 操作系统级别的创新率较低.</p>
<p><img src="images/what-is-ebpf/overview.png" alt="overview"></p>
<p>eBPF 从根本上改变了这种一成不变的状态. 通过允许在操作系统中执行沙盒程序, 开发者可以通过执行 eBPF 程序, 来给运行中的操作系统添加额外的能力. 就像在本地使用即时编译器(JIT)和验证引擎一样, 操作系统可以保证安全性和执行效率. 这催生了不少基于 eBPF 的项目, 涵盖了广泛的用例, 包括下一代网络、可观察性和安全功能.</p>
<p>今天, eBPF 被广泛用于各种用例: 在现代化的数据中心和云原生环境中提供高性能网络和负载均衡, 以较低的开销提取细粒度的可观察性安全数据, 帮助应用程序开发者追踪应用, 并能够在性能故障分析、预防性应用和容器运行时安全执法等方面提供帮助. 它的可能性是无限的, 关于 eBPF 的创新才刚开始.</p>
<h3 id="什么是-ebpfio">什么是 eBPF.io?</h3>
<p>eBPF.io 是以 eBPF 为主题, 每个人学习和协作的地方. eBPF 是一个开源社区, 每个人可以实践或者分享. 不论你是想阅读 eBPF 第一篇介绍文章, 还是发现更多阅读素材, 抑或是为变成 eBPF 主项目贡献者迈出第一步, eBPF.io 会一直陪伴你帮助你.</p>
<h2 id="介绍-ebpf">介绍 eBPF</h2>
<p>下面的章节是关于 eBPF 的快速介绍. 如果你想了解更多, 查看 <a href="https://cilium.readthedocs.io/en/stable/bpf/">eBPF &amp; XDP Reference Guide</a>. 不管你是一名从事 eBPF 的开发者, 或是有兴趣使用 eBPF 作为解决方案, 理解基础概念和架构都是很有用的.</p>
<h3 id="hook-概览">Hook 概览</h3>
<p>eBPF 程序是事件驱动的, 能在内核或应用程序执行到一个特定的 hook 点时执行. 预定义的 hooks 包含系统调用, 函数出/入口, 内核追踪点, 网络事件等等.</p>
<p><img src="images/what-is-ebpf/syscall_hook.png" alt="syscall_hook"></p>
<p>如果预定义 hook 不能满足需求, 也可以创建内核探针(kprobe)或者用户探针(uprobe), 在内核/用户应用程序的任何位置, 把探针附加到 eBPF 程序上.</p>
<h3 id="ebpf-程序怎么写">eBPF 程序怎么写?</h3>
<p>在很多场景中, 用户不需要直接使用 eBPF, 而是通过一些项目, 比如 <a href="https://ebpf.io/projects/#cilium">cilium</a>, <a href="https://ebpf.io/projects/#bcc">bcc</a> 或 <a href="https://ebpf.io/projects/#bpftrace">bpftrace</a>, 它们是 eBPF 上层的抽象, 提供了使用 eBPF 实现的特定功能, 用户无需直接编写 eBPF 程序.</p>
<p><img src="images/what-is-ebpf/clang.png" alt="clang"></p>
<p>如果没有高级抽象, 就需要直接编写 eBPF 程序. Linux 内核要器加载字节码形式的 eBPF 程序. 虽然可以直接编写字节码, 但是更普遍的开发实践是借用像 <a href="https://llvm.org/">LLVM</a> 这样的编译器, 把伪 C 代码编译成字节码.</p>
<h3 id="加载器--验证架构">加载器 &amp; 验证架构</h3>
<p>当所需的钩子被识别后, 可以使用 bpf 系统调用将 eBPF 程序加载到 Linux 内核中. 这通常使用一个可用的 eBPF 工具库来完成. 下一节将介绍一些可用的开发工具链.</p>
<p><img src="images/what-is-ebpf/go.png" alt="go"></p>
<p>当程序加载到 Linux 内核中时, 它在附加到请求的钩子之前要经过两个步骤:</p>
<h3 id="验证">验证</h3>
<p>这一步是为了确保 eBPF 程序安全执行. 它验证程序是否满足一些条件, 比如:</p>
<ul>
<li>加载 eBPF 程序的进程拥有所需的能力(特权). 除非启用非特权 eBPF, 否则只有特权进程才能加载 eBPF 程序.</li>
<li>该程序不能崩溃或者以其他方式伤害操作系统.</li>
<li>该程序必须总是能执行完(即程序不会死循环, 阻止后面的处理).</li>
</ul>
<h3 id="即时编译-jit">即时编译 (JIT)</h3>
<p>该步骤将通用字节码翻译成机器特定的指令集, 以优化程序的执行速度. 这使 eBPF 程序像原生编译的内核代码或者像已加载的内核模块代码一样高效运行.</p>
<h3 id="maps">Maps</h3>
<p>eBPF 程序一个重要能力是: 能够共享收集的信息, 能够存储状态. 为了实现该能力, eBPF 程序借用 Maps 来存储/获取数据, 它支持丰富的数据结构. 通过系统调用, 可以从 eBPF 程序或者用户空间应用访问 maps.</p>
<p><img src="images/what-is-ebpf/map_architecture.png" alt="map_architecture"></p>
<p>为了解 map 类型的多样性, 下面是不完整的 map 类型列表. 这些类型的变量同时是 共享变量 和 per-CPU 变量.</p>
<ul>
<li>Hash tables, Arrays 哈希表, 数组</li>
<li>LRU (Least Recently Used) 最近最少使用</li>
<li>Ring Buffer 环形缓冲区</li>
<li>Stack Trace 堆栈跟踪</li>
<li>LPM (Longest Prefix Match) 最长前缀匹配</li>
<li>&hellip;</li>
</ul>
<h3 id="帮助函数">帮助函数</h3>
<p>eBPF 程序不能随意调用内核函数. 如果允许的话, 将会把 eBPF 程序绑定到特定的内核版本, 这会使程序的兼容性复杂化. 所以, eBPF 程序转而使用帮助函数, 它是内核提供的大家熟知的稳定的 API.</p>
<p><img src="images/what-is-ebpf/helper.png" alt="helper"></p>
<p>可用的帮助函数还在持续发展中, 例如:</p>
<ul>
<li>生成随机数</li>
<li>获取当前时间和日期</li>
<li>访问 eBPF map</li>
<li>获取 process/cgroup 上下文</li>
<li>网络数据包处理和转发逻辑</li>
</ul>
<h3 id="尾调用--函数调用">尾调用 &amp; 函数调用</h3>
<p>eBPF 程序可以组合使用尾调用和函数调用(tail &amp; function calls). 函数调用允许在 eBPF 程序中定义和调用函数. 尾调用可以调用执行其他 eBPF 程序, 并替换执行上下文, 类似于 <code>execve()</code> 系统调用对常规进程的操作方式.</p>
<p><img src="images/what-is-ebpf/tailcall.png" alt="tailcall"></p>
<h3 id="ebpf-安全">eBPF 安全</h3>
<p><em>权利越大, 责任越大</em></p>
<p>eBPF 是一项伟大的技术, 当下在很多关键软件中都扮演了核心的角色. 在 eBPF 程序开发过程中, 当 eBPF 进入 Linux 内核时, eBPF 的安全性就变得异常重要. eBPF 的安全性通过下面几点来保证:</p>
<h4 id="要求特权">要求特权</h4>
<p>除非开启非特权 eBPF, 所有企图加载 eBPF 程序到内核的进程必须在特权模式（root）下运行，或者必须获得 CAP_BPF 能力. 这意味着非授信的程序不能加载 eBPF 程序.</p>
<p>如果开启非特权 eBPF, 非特权进程可以加载特定的 eBPF 程序, 它们仅能使用被缩减的功能集合, 并且将受限制的访问内核.</p>
<h4 id="验证器">验证器</h4>
<p>如果进程允许加载 eBPF 程序, 所有的程序都要经过 eBPF 验证器, 验证器来确保程序本身的安全性. 这意味着:</p>
<ul>
<li>通过验证的程序一定会执行完, 比如, eBPF 程序不会卡住或死循环. eBPF 程序可以包含有边界的循环, 但是验证器要求, 循环必须具有可以被执行到的退出条件.</li>
<li>程序不能使用任何未初始化的变量或者越界访问内存.</li>
<li>程序必须在系统要求的大小范围内. 随意大的 eBPF 程序是无法加载的.</li>
<li>程序必须具备有限的复杂性. 验证器会评估所有可能的执行路径, 并且必须在配置的复杂度范围内完成分析.</li>
</ul>
<h4 id="加固">加固</h4>
<p>完成验证之后, 根据 eBPF 程序是从特权进程还是非特权进程加载, 来决定是否加固的 eBPF 程序. 这包括:</p>
<ul>
<li><strong>程序执行保护</strong>: 存有 eBPF 程序的内核内存是被保护的并且是只读的. 不管是内核 bug 或者是被恶意操纵, 内核都将崩溃, 而不是允许它继续执行损坏/被操纵的程序.</li>
<li><strong>Mitigation against Spectre</strong>: Under speculation CPUs may mispredict branches and leave observable side effects that could be extracted through a side channel. 举几个例子: eBPF programs mask memory access in order to redirect access under transient instructions to controlled areas, the verifier also follows program paths accessible only under speculative execution and the JIT compiler emits Retpolines in case tail calls cannot be converted to direct calls.</li>
<li><strong>常量 blinding</strong>: 代码中的所有常量都被 blinded, 以防止 JIT spraying 攻击. 这可以避免: 当存在某种内核 bug 的情况下, 攻击者可以把可执行代码作为常量注入, 从而让攻击者跳转到 eBPF 程序的内存区域来执行代码.</li>
</ul>
<h4 id="抽象的运行时上下文">抽象的运行时上下文</h4>
<p>eBPF 程序不能直接访问任意内核内存. 必须通过 <strong>eBPF 助手函数</strong>访问位于程序上下文之外的数据和数据结构. 这保证了一致性的数据访问, 并使任何此类访问均受制于 eBPF 程序的权限, 例如如果可以保证修改是安全的, 则允许运行的 eBPF 程序修改某些数据结构的数据. eBPF 程序不能随机修改内核中的数据结构.</p>
<h2 id="为什么使用-ebpf">为什么使用 eBPF?</h2>
<h3 id="可编程的力量">可编程的力量</h3>
<p>还记得 GeoCities 吗? 20年前, 网页几乎全都是用静态标记语言(HTML)写的, 网页基本上是一种应用程序(浏览器)能打开的文件. 再看今天, 网页已经变成了非常成熟的应用, 并且 WEB 已经取代了绝大部分编译语言写的应用. 是什么成就了这次革命?</p>
<p><img src="images/what-is-ebpf/geocities.png" alt="geocities"></p>
<p>简单来说, 就是引入 JavaScript 之后的可编程性. 它开启了一场大规模的革命, 几乎将浏览器变成了独立的操作系统.</p>
<p>为什么呢? 程序员不再受限于特定的浏览器版本. 没有去说服标准机构去定义更多需要的 HTML 标签, 相反, 而是提供了一些必要的构建模块, 将浏览器底层的演进和运行在其上层的应用进行分离. 这样说可能过于简单, 因为 HTML 的确做了不小的贡献, 也的确有所发展, 但是 HTML 本身的变革还不够.</p>
<p>在举这个例子并将其应用到 eBPF 之前, 让我们看一下对引入 JavaScript 至关重要的几个关键方面:</p>
<ul>
<li><strong>安全性</strong>: 不受信任的代码在用户的浏览器中运行. 这是通过沙盒 JavaScript 程序和抽象对浏览器数据的访问来解决的.</li>
<li><strong>持续交付</strong>: 在不需要浏览器发新版本的情况下, 程序要能不断更新. 这得益于浏览器低级的(low-level)构建模块, 它能构建任意的逻辑.</li>
<li><strong>性能</strong>: 必须以最小的开销提供可编程性. 这得益于即时编译器(JIT).</li>
</ul>
<p>上面说的所有内容, 在 eBPF 中都能找到:</p>
<h3 id="ebpf-对-linux-内核的影响">eBPF 对 Linux 内核的影响</h3>
<p>现在我们回到 eBPF. 为了理解 eBPF 可编程性在 Linux 内核上的影响, 我们来看张图片, 它有助于我们对 Linux 内核的架构进行理解, 并且能了解它是如何与应用程序和硬件进行交互的.</p>
<p><img src="images/what-is-ebpf/kernel_arch.png" alt="kernel_arch"></p>
<p>Linux 内核的主要目的是抽象硬件或虚拟硬件, 并提供一致的 API(系统调用), 允许应用程序运行和共享资源. 为了实现这一点, 维护了大量的子系统和层来分配这些职责. 每个子系统通常允许某种级别的配置来满足不同的用户需求. 如果没办法通过配置满足某种需求, 则需要更改内核. 从历史上看, 有两种选择:</p>
<table>
<thead>
<tr>
<th style="text-align:left">原生支持</th>
<th style="text-align:left">内核模块</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1. 更改内核源代码并说服 Linux 内核社区</td>
<td style="text-align:left">1. 写一个新的内核模块</td>
</tr>
<tr>
<td style="text-align:left">2. 等几年新内核版本上市</td>
<td style="text-align:left">2. 定期修复它, 因为每个内核版本都可能破坏它</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">3. 由于缺乏安全边界, 有损坏 Linux 内核的风险</td>
</tr>
</tbody>
</table>
<p>在不需要改变内核源码或者加载内核模块的情况下, eBPF 为重新编程内核行为提供了一种新的选择. 在很多地方, 这很像 JavaScript 和其他脚本语言, 它们让那些改变难度大, 成本高的系统开始演进.</p>
<h2 id="开发工具链">开发工具链</h2>
<p>有几个开发工具链来能够协助 eBPF 程序的开发和管理. 它们能满足用户的不同需求:</p>
<h3 id="bcc">bcc</h3>
<p>BCC 是一个框架, 能够让用户编写嵌入了 eBPF 程序的 python 程序. 该框架主要用来分析和跟踪应用/系统, eBPF 在其中主要负责收集统计数据或生成事件, 然后, 对应的用户空间程序会收集这些数据并以易读的方式进行展示. 运行 python 程序会生成 eBPF 字节码并将其加载进内核.</p>
<p><img src="images/what-is-ebpf/bcc.png" alt="bcc"></p>
<h3 id="bpftrace">bpftrace</h3>
<p>bpftrace 是 Linux eBPF 的高级跟踪语言, 可用于最新的 Linux 内核(4.x). bpftrace 使用 LLVM 作为后端将脚本编译为 eBPF 字节码，并利用 BCC 与 Linux eBPF 子系统以及现有的 Linux 跟踪功能进行交互: 内核动态跟踪(kprobes)、用户级动态跟踪(uprobes)和跟踪点(tracepoints). bpftrace 语言的灵感来自 awk、C 和以前的跟踪器(如 DTrace 和 SystemTap).</p>
<p><img src="images/what-is-ebpf/bpftrace.png" alt="bpftrace"></p>
<h3 id="ebpf-go-类库">eBPF Go 类库</h3>
<p>eBPF Go 库提供了一个通用的 eBPF 库, 它将获取 eBPF 字节码的过程与 eBPF 程序的加载和管理分离. eBPF 程序通常是通过编写高级语言创建的, 然后使用 clang/LLVM 编译器编译为 eBPF 字节码.</p>
<p><img src="images/what-is-ebpf/go.png" alt="go"></p>
<h3 id="libbpf-cc-类库">libbpf C/C++ 类库</h3>
<p>libbpf 库是一个基于 C/C++ 的通用 eBPF 库. 它提供给应用程序一种易用的 API 来抽象化 BPF 系统调用, 并将 eBPF 字节码(clang/LLVM 编译器生成)加载到内核的过程与之分离.</p>
<p><img src="images/what-is-ebpf/libbpf.png" alt="libbpf"></p>
<h2 id="阅读更多">阅读更多</h2>
<p>如果你想学习更多的 eBPF 知识, 阅读下面的材料:</p>
<h3 id="文档">文档</h3>
<ul>
<li><a href="https://docs.cilium.io/en/stable/bpf/">BPF &amp; XDP Reference Guide</a><br>
Cilium 文档, 2020年8月</li>
<li><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF Documentation</a><br>
Linux 内核中的 BPF 介绍文档</li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/bpf_design_QA.rst">BPF Design Q&amp;A</a><br>
内核相关的 eBPF 问答</li>
</ul>
<h3 id="教程">教程</h3>
<ul>
<li><a href="https://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">Learn eBPF Tracing: Tutorial and Examples</a><br>
Brendan Gregg 的博客, 2019年1月</li>
<li><a href="https://github.com/xdp-project/xdp-tutorial">XDP Hands-On Tutorials</a><br>
很多作者, 2019年</li>
<li><a href="https://facebookmicrosites.github.io/bpf/blog/">BCC, libbpf and BPF CO-RE Tutorials</a><br>
Facebook 的 BPF 博客, 2020年</li>
</ul>
<h3 id="发言">发言</h3>
<h4 id="基础">基础</h4>
<ul>
<li><a href="">eBPF and Kubernetes: Little Helper Minions for Scaling Microservices (Slides)</a><br>
Daniel Borkmann, KubeCon EU, Aug 2020</li>
<li><a href="">eBPF - Rethinking the Linux Kernel (Slides)</a><br>
Thomas Graf, QCon London, April 2020</li>
<li><a href="">BPF as a revolutionary technology for the container landscape (Slides)</a><br>
Daniel Borkmann, FOSDEM, Feb 2020</li>
<li><a href="">BPF at Facebook</a><br>
Alexei Starovoitov, Performance Summit, Dec 2019</li>
<li><a href="">BPF: A New Type of Software (Slides)</a><br>
Brendan Gregg, Ubuntu Masters, Oct 2019</li>
<li><a href="">The ubiquity but also the necessity of eBPF as a technology</a><br>
David S. Miller, Kernel Recipes, Oct 2019</li>
</ul>
<h4 id="深入">深入</h4>
<ul>
<li><a href="">BPF and Spectre: Mitigating transient execution attacks (Slides)</a><br>
Daniel Borkmann, eBPF Summit, Aug 2021</li>
<li><a href="">BPF Internals (Slides)</a><br>
Brendan Gregg, USENIX LISA, Jun 2021</li>
</ul>
<h4 id="cilium">Cilium</h4>
<ul>
<li><a href="">Advanced BPF Kernel Features for the Container Age (Slides)</a><br>
Daniel Borkmann, FOSDEM, Feb 2021</li>
<li><a href="">Kubernetes Service Load-Balancing at Scale with BPF &amp; XDP (Slides)</a><br>
Daniel Borkmann &amp; Martynas Pumputis, Linux Plumbers, Aug 2020</li>
<li><a href="">Liberating Kubernetes from kube-proxy and iptables (Slides)</a><br>
Martynas Pumputis, KubeCon US 2019</li>
<li><a href="">Understanding and Troubleshooting the eBPF Datapath in Cilium (Slides)</a><br>
Nathan Sweet, KubeCon US 2019</li>
<li><a href="">Transparent Chaos Testing with Envoy, Cilium and BPF (Slides)</a><br>
Thomas Graf, KubeCon EU 2019</li>
<li><a href="">Cilium - Bringing the BPF Revolution to Kubernetes Networking and Security (Slides)</a><br>
Thomas Graf, All Systems Go!, Berlin, Sep 2018</li>
<li><a href="">How to Make Linux Microservice-Aware with eBPF (Slides)</a><br>
Thomas Graf, QCon San Francisco, 2018</li>
<li><a href="">Accelerating Envoy with the Linux Kernel</a><br>
Thomas Graf, KubeCon EU 2018</li>
<li><a href="">Cilium - Network and Application Security with BPF and XDP (Slides)</a><br>
Thomas Graf, DockerCon Austin, Apr 2017</li>
</ul>
<h4 id="hubble">Hubble</h4>
<ul>
<li><a href="">Hubble - eBPF Based Observability for Kubernetes</a><br>
Sebastian Wicki, KubeCon EU, Aug 2020</li>
</ul>
<h3 id="图书">图书</h3>
<ul>
<li><a href="">Systems Performance: Enterprise and the Cloud, 2nd Edition</a><br>
Brendan Gregg, Addison-Wesley Professional Computing Series, 2020</li>
<li><a href="">BPF Performance Tools</a><br>
Brendan Gregg, Addison-Wesley Professional Computing Series, Dec 2019</li>
<li><a href="">Linux Observability with BPF</a><br>
David Calavera, Lorenzo Fontana, O&rsquo;Reilly, Nov 2019</li>
</ul>
<h3 id="文章--博客">文章 &amp; 博客</h3>
<ul>
<li><a href="">BPF for security - and chaos - in Kubernetes</a><br>
Sean Kerner, LWN, Jun 2019</li>
<li><a href="">Linux Technology for the New Year: eBPF</a><br>
Joab Jackson, Dec 2018</li>
<li><a href="https://lwn.net/Articles/740157/">A thorough introduction to eBPF</a><br>
Matt Fleming, LWN, Dec 2017</li>
<li><a href="">Cilium, BPF and XDP</a><br>
Google Open Source Blog, Nov 2016</li>
<li><a href="">Archive of various articles on BPF</a><br>
LWN, since Apr 2011</li>
<li><a href="">Various articles on BPF by Cloudflare</a><br>
Cloudflare, since March 2018</li>
<li><a href="">Various articles on BPF by Facebook</a><br>
Facebook, since August 2018</li>
</ul>
</div>
    
    <div class="col-12 col-md-6 mb-2 "><p>这篇文档主要演示了 opensnoop(Linux eBPF/bcc) 工具的使用.</p>
<h2 id="示例">示例</h2>
<p>opensnoop 在系统范围内跟踪 open() 系统调用，并打印各种详细信息.</p>
<p>示例输出:</p>
<pre tabindex="0"><code># ./opensnoop
PID    COMM      FD ERR PATH
17326  &lt;...&gt;      7   0 /sys/kernel/debug/tracing/trace_pipe
1576   snmpd      9   0 /proc/net/dev
1576   snmpd     11   0 /proc/net/if_inet6
1576   snmpd     11   0 /proc/sys/net/ipv4/neigh/eth0/retrans_time_ms
1576   snmpd     11   0 /proc/sys/net/ipv6/neigh/eth0/retrans_time_ms
1576   snmpd     11   0 /proc/sys/net/ipv6/conf/eth0/forwarding
1576   snmpd     11   0 /proc/sys/net/ipv6/neigh/eth0/base_reachable_time_ms
1576   snmpd     11   0 /proc/sys/net/ipv4/neigh/lo/retrans_time_ms
1576   snmpd     11   0 /proc/sys/net/ipv6/neigh/lo/retrans_time_ms
1576   snmpd     11   0 /proc/sys/net/ipv6/conf/lo/forwarding
1576   snmpd     11   0 /proc/sys/net/ipv6/neigh/lo/base_reachable_time_ms
1576   snmpd      9   0 /proc/diskstats
1576   snmpd      9   0 /proc/stat
1576   snmpd      9   0 /proc/vmstat
1956   supervise  9   0 supervise/status.new
1956   supervise  9   0 supervise/status.new
17358  run        3   0 /etc/ld.so.cache
17358  run        3   0 /lib/x86_64-linux-gnu/libtinfo.so.5
17358  run        3   0 /lib/x86_64-linux-gnu/libdl.so.2
17358  run        3   0 /lib/x86_64-linux-gnu/libc.so.6
17358  run       -1   6 /dev/tty
17358  run        3   0 /proc/meminfo
17358  run        3   0 /etc/nsswitch.conf
17358  run        3   0 /etc/ld.so.cache
17358  run        3   0 /lib/x86_64-linux-gnu/libnss_compat.so.2
17358  run        3   0 /lib/x86_64-linux-gnu/libnsl.so.1
17358  run        3   0 /etc/ld.so.cache
17358  run        3   0 /lib/x86_64-linux-gnu/libnss_nis.so.2
17358  run        3   0 /lib/x86_64-linux-gnu/libnss_files.so.2
17358  run        3   0 /etc/passwd
17358  run        3   0 ./run
^C
</code></pre><p>在跟踪时，snmpd 进程打开了各种 /proc 文件(读取指标). 另外, 一个 “run” 进程读取各种库和配置文件(看起来像
正在启动: 一个新进程).</p>
<p>如果在应用程序启动期间使用, <strong>opensnoop 可用于发现配置和日志文件</strong>.</p>
<h2 id="过滤-pid">过滤 PID</h2>
<p>-p 选项可用于在内核中过滤 PID. 这里我将它与 -T 一起使用来打印时间戳:</p>
<pre tabindex="0"><code>$ ./opensnoop -Tp 1956
TIME(s)       PID    COMM               FD ERR PATH
0.000000000   1956   supervise           9   0 supervise/status.new
0.000289999   1956   supervise           9   0 supervise/status.new
1.023068000   1956   supervise           9   0 supervise/status.new
1.023381997   1956   supervise           9   0 supervise/status.new
2.046030000   1956   supervise           9   0 supervise/status.new
2.046363000   1956   supervise           9   0 supervise/status.new
3.068203997   1956   supervise           9   0 supervise/status.new
3.068544999   1956   supervise           9   0 supervise/status.new
</code></pre><p>这表明 supervise 进程每秒打开2次 status.new 文件.</p>
<h2 id="包含过滤-uid">包含/过滤 UID</h2>
<p>-U 选项在输出中包含 UID:</p>
<pre tabindex="0"><code># ./opensnoop -U
UID   PID    COMM               FD ERR PATH
0     27063  vminfo              5   0 /var/run/utmp
103   628    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
103   628    dbus-daemon        18   0 /usr/share/dbus-1/system-services
103   628    dbus-daemon        -1   2 /lib/dbus-1/system-services
</code></pre><p>-u 选项过滤 UID:</p>
<pre tabindex="0"><code># ./opensnoop -Uu 1000
UID   PID    COMM               FD ERR PATH
1000  30240  ls                  3   0 /etc/ld.so.cache
1000  30240  ls                  3   0 /lib/x86_64-linux-gnu/libselinux.so.1
1000  30240  ls                  3   0 /lib/x86_64-linux-gnu/libc.so.6
1000  30240  ls                  3   0 /lib/x86_64-linux-gnu/libpcre.so.3
1000  30240  ls                  3   0 /lib/x86_64-linux-gnu/libdl.so.2
1000  30240  ls                  3   0 /lib/x86_64-linux-gnu/libpthread.so.0
</code></pre><h2 id="过滤失败的-opens">过滤失败的 opens</h2>
<p>-x 选项仅打印失败的 opens:</p>
<pre tabindex="0"><code># ./opensnoop -x
PID    COMM      FD ERR PATH
18372  run       -1   6 /dev/tty
18373  run       -1   6 /dev/tty
18373  multilog  -1  13 lock
18372  multilog  -1  13 lock
18384  df        -1   2 /usr/share/locale/en_US.UTF-8/LC_MESSAGES/coreutils.mo
18384  df        -1   2 /usr/share/locale/en_US.utf8/LC_MESSAGES/coreutils.mo
18384  df        -1   2 /usr/share/locale/en_US/LC_MESSAGES/coreutils.mo
18384  df        -1   2 /usr/share/locale/en.UTF-8/LC_MESSAGES/coreutils.mo
18384  df        -1   2 /usr/share/locale/en.utf8/LC_MESSAGES/coreutils.mo
18384  df        -1   2 /usr/share/locale/en/LC_MESSAGES/coreutils.mo
18385  run       -1   6 /dev/tty
18386  run       -1   6 /dev/tty
</code></pre><p>这里捕获了一个 df 命令无法打开 coreutils.mo 文件, 并尝试从其他目录打开.</p>
<p>列 ERR 表示系统错误码, 2 代表 ENOENT: no such file or directory.</p>
<p>可以使用 -d 选项设置最长跟踪持续时间. 例如, 要跟踪 2秒:</p>
<pre tabindex="0"><code># ./opensnoop -d 2
PID    COMM               FD ERR PATH
2191   indicator-multi    11   0 /sys/block
2191   indicator-multi    11   0 /sys/block
2191   indicator-multi    11   0 /sys/block
2191   indicator-multi    11   0 /sys/block
2191   indicator-multi    11   0 /sys/block
</code></pre><h2 id="过滤进程名称">过滤进程名称</h2>
<p>-n 选项可用于过滤进程名称(部分匹配):</p>
<pre tabindex="0"><code># ./opensnoop -n ed

PID    COMM               FD ERR PATH
2679   sed                 3   0 /etc/ld.so.cache
2679   sed                 3   0 /lib/x86_64-linux-gnu/libselinux.so.1
2679   sed                 3   0 /lib/x86_64-linux-gnu/libc.so.6
2679   sed                 3   0 /lib/x86_64-linux-gnu/libpcre.so.3
2679   sed                 3   0 /lib/x86_64-linux-gnu/libdl.so.2
2679   sed                 3   0 /lib/x86_64-linux-gnu/libpthread.so.0
2679   sed                 3   0 /proc/filesystems
2679   sed                 3   0 /usr/lib/locale/locale-archive
2679   sed                -1   2
2679   sed                 3   0 /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
2679   sed                 3   0 /dev/null
2680   sed                 3   0 /etc/ld.so.cache
2680   sed                 3   0 /lib/x86_64-linux-gnu/libselinux.so.1
2680   sed                 3   0 /lib/x86_64-linux-gnu/libc.so.6
2680   sed                 3   0 /lib/x86_64-linux-gnu/libpcre.so.3
2680   sed                 3   0 /lib/x86_64-linux-gnu/libdl.so.2
2680   sed                 3   0 /lib/x86_64-linux-gnu/libpthread.so.0
2680   sed                 3   0 /proc/filesystems
2680   sed                 3   0 /usr/lib/locale/locale-archive
2680   sed                -1   2
^C
</code></pre><p>这里捕获了 “sed” 命令，是因为命令中使用了命令名称部分匹配 “-n ed”</p>
<h2 id="过滤标志">过滤标志</h2>
<p>-e 选项能打印出额外的列; 例如，以下输出包含传递给 open(2) 的标志(以八进制表示):</p>
<pre tabindex="0"><code># ./opensnoop -e
PID    COMM               FD ERR FLAGS    PATH
28512  sshd               10   0 00101101 /proc/self/oom_score_adj
28512  sshd                3   0 02100000 /etc/ld.so.cache
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libwrap.so.0
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libaudit.so.1
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libpam.so.0
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libselinux.so.1
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libsystemd.so.0
28512  sshd                3   0 02100000 /usr/lib/x86_64-linux-gnu/libcrypto.so.1.0.2
28512  sshd                3   0 02100000 /lib/x86_64-linux-gnu/libutil.so.1
</code></pre><p>-f 选项能基于 open(2) 调用的标志进行过滤, 比如:</p>
<pre tabindex="0"><code># ./opensnoop -e -f O_WRONLY -f O_RDWR
PID    COMM               FD ERR FLAGS    PATH
28084  clear_console       3   0 00100002 /dev/tty
28084  clear_console      -1  13 00100002 /dev/tty0
28084  clear_console      -1  13 00100001 /dev/tty0
28084  clear_console      -1  13 00100002 /dev/console
28084  clear_console      -1  13 00100001 /dev/console
28051  sshd                8   0 02100002 /var/run/utmp
28051  sshd                7   0 00100001 /var/log/wtmp
</code></pre><h2 id="基于-cgroup-集进行过滤">基于 cgroup 集进行过滤</h2>
<p>&ndash;cgroupmap 选项基于 cgroup 集进行过滤, 它用于使用外部创建的映射.</p>
<pre tabindex="0"><code># ./opensnoop --cgroupmap /sys/fs/bpf/test01
</code></pre><p>更多信息, 查看 <a href="https://github.com/iovisor/bcc/blob/master/docs/special_filtering.md">docs/special_filtering.md</a></p>
<h2 id="usage-说明">USAGE 说明</h2>
<pre tabindex="0"><code># ./opensnoop -h
usage: opensnoop.py [-h] [-T] [-U] [-x] [-p PID] [-t TID]
                    [--cgroupmap CGROUPMAP] [--mntnsmap MNTNSMAP] [-u UID]
                    [-d DURATION] [-n NAME] [-e] [-f FLAG_FILTER]

跟踪 open() 系统调用

optional arguments:
  -h, --help            show this help message and exit
  -T, --timestamp       include timestamp on output
  -U, --print-uid       include UID on output
  -x, --failed          only show failed opens
  -p PID, --pid PID     trace this PID only
  -t TID, --tid TID     trace this TID only
  --cgroupmap CGROUPMAP
                        trace cgroups in this BPF map only
  --mntnsmap MNTNSMAP   trace mount namespaces in this BPF map on
  -u UID, --uid UID     trace this UID only
  -d DURATION, --duration DURATION
                        total duration of trace in seconds
  -n NAME, --name NAME  only print process names containing this name
  -e, --extended_fields
                        show extended fields
  -f FLAG_FILTER, --flag_filter FLAG_FILTER
                        filter on flags argument (e.g., O_WRONLY)

examples:
    ./opensnoop           # trace all open() syscalls
    ./opensnoop -T        # include timestamps
    ./opensnoop -U        # include UID
    ./opensnoop -x        # only show failed opens
    ./opensnoop -p 181    # only trace PID 181
    ./opensnoop -t 123    # only trace TID 123
    ./opensnoop -u 1000   # only trace UID 1000
    ./opensnoop -d 10     # trace for 10 seconds only
    ./opensnoop -n main   # only print process names containing &quot;main&quot;
    ./opensnoop -e        # show extended fields
    ./opensnoop -f O_WRONLY -f O_RDWR  # only print calls for writing
    ./opensnoop --cgroupmap mappath  # only trace cgroups in this BPF map
    ./opensnoop --mntnsmap mappath   # only trace mount namespaces in the map
</code></pre></div>
    
    <div class="col-12 col-md-6 mb-2 "><p>这篇文档主要演示了 tcplife(Linux eBPF/bcc) 工具的使用.</p>
<h2 id="示例">示例</h2>
<p>tcplife 总结了在跟踪期间打开和关闭的 TCP 会话. 比如:</p>
<pre tabindex="0"><code># ./tcplife
PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
22597 recordProg 127.0.0.1       46644 127.0.0.1       28527     0     0 0.23
3277  redis-serv 127.0.0.1       28527 127.0.0.1       46644     0     0 0.28
22598 curl       100.66.3.172    61620 52.205.89.26    80        0     1 91.79
22604 curl       100.66.3.172    44400 52.204.43.121   80        0     1 121.38
22624 recordProg 127.0.0.1       46648 127.0.0.1       28527     0     0 0.22
3277  redis-serv 127.0.0.1       28527 127.0.0.1       46648     0     0 0.27
22647 recordProg 127.0.0.1       46650 127.0.0.1       28527     0     0 0.21
3277  redis-serv 127.0.0.1       28527 127.0.0.1       46650     0     0 0.26
[...]
</code></pre><p>这捕获了一个程序 “recordProg”, 它建立了一些到 “redis-serv” 的短暂的 TCP 连接, 每个连接持续大约 0.25 毫秒. 还有几个 “curl” 会话也被跟踪, 连接到端口 80, 持续了 91 和 121 毫秒.</p>
<p>此工具对于工作负载表征和流量统计很有用: <strong>识别正在发生的连接以及传输的字节</strong>.</p>
<p>在这个例子中, 我上传了一个 10 Mbyte 的文件到服务器, 然后再次使用 scp 下载:</p>
<pre tabindex="0"><code># ./tcplife
PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
7715  recordProg 127.0.0.1       50894 127.0.0.1       28527     0     0 0.25
3277  redis-serv 127.0.0.1       28527 127.0.0.1       50894     0     0 0.30
7619  sshd       100.66.3.172    22    100.127.64.230  63033     5 10255 3066.79
7770  recordProg 127.0.0.1       50896 127.0.0.1       28527     0     0 0.20
3277  redis-serv 127.0.0.1       28527 127.0.0.1       50896     0     0 0.24
7793  recordProg 127.0.0.1       50898 127.0.0.1       28527     0     0 0.23
3277  redis-serv 127.0.0.1       28527 127.0.0.1       50898     0     0 0.27
7847  recordProg 127.0.0.1       50900 127.0.0.1       28527     0     0 0.24
3277  redis-serv 127.0.0.1       28527 127.0.0.1       50900     0     0 0.29
7870  recordProg 127.0.0.1       50902 127.0.0.1       28527     0     0 0.29
3277  redis-serv 127.0.0.1       28527 127.0.0.1       50902     0     0 0.30
7798  sshd       100.66.3.172    22    100.127.64.230  64925 10265     6 2176.15
[...]
</code></pre><p>可以看到 sshd 接收了 10 MB, 然后再传输出去. 看起来, 接收(3.07 秒)比传输(2.18 秒)慢.</p>
<h2 id="宽显">宽显</h2>
<p>进程名称被截断为 10 个字符. 通过使用宽选项 -w, 列宽变为 16 个字符. IP 地址栏也更宽, 以适合 IPv6 地址:</p>
<pre tabindex="0"><code># ./tcplife -w
PID   COMM             IP LADDR                      LPORT RADDR                      RPORT  TX_KB  RX_KB MS
26315 recordProgramSt  4  127.0.0.1                  44188 127.0.0.1                  28527      0      0 0.21
3277  redis-server     4  127.0.0.1                  28527 127.0.0.1                  44188      0      0 0.26
26320 ssh              6  fe80::8a3:9dff:fed5:6b19   22440 fe80::8a3:9dff:fed5:6b19   22         1      1 457.52
26321 sshd             6  fe80::8a3:9dff:fed5:6b19   22    fe80::8a3:9dff:fed5:6b19   22440      1      1 458.69
26341 recordProgramSt  4  127.0.0.1                  44192 127.0.0.1                  28527      0      0 0.27
3277  redis-server     4  127.0.0.1                  28527 127.0.0.1                  44192      0      0 0.32
</code></pre><h2 id="添加时间戳">添加时间戳</h2>
<p>可以使用 -t 添加时间戳:</p>
<pre tabindex="0"><code># ./tcplife -t
TIME(s)   PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
0.000000  5973  recordProg 127.0.0.1       47986 127.0.0.1       28527     0     0 0.25
0.000059  3277  redis-serv 127.0.0.1       28527 127.0.0.1       47986     0     0 0.29
1.022454  5996  recordProg 127.0.0.1       47988 127.0.0.1       28527     0     0 0.23
1.022513  3277  redis-serv 127.0.0.1       28527 127.0.0.1       47988     0     0 0.27
2.044868  6019  recordProg 127.0.0.1       47990 127.0.0.1       28527     0     0 0.24
2.044924  3277  redis-serv 127.0.0.1       28527 127.0.0.1       47990     0     0 0.28
3.069136  6042  recordProg 127.0.0.1       47992 127.0.0.1       28527     0     0 0.22
3.069204  3277  redis-serv 127.0.0.1       28527 127.0.0.1       47992     0     0 0.28
</code></pre><p>这表明 recordProg 进程每秒连接一次.</p>
<p>另外 -T 选项可以使用 HH:MM:SS 格式时间戳.</p>
<h2 id="逗号分隔列表">逗号分隔列表</h2>
<p>-s 选项可以指定逗号分隔的列表模式. 这里同时使用了 -t 和 -T 类型的时间戳:</p>
<pre tabindex="0"><code># ./tcplife -stT
TIME,TIME(s),PID,COMM,IP,LADDR,LPORT,RADDR,RPORT,TX_KB,RX_KB,MS
23:39:38,0.000000,7335,recordProgramSt,4,127.0.0.1,48098,127.0.0.1,28527,0,0,0.26
23:39:38,0.000064,3277,redis-server,4,127.0.0.1,28527,127.0.0.1,48098,0,0,0.32
23:39:39,1.025078,7358,recordProgramSt,4,127.0.0.1,48100,127.0.0.1,28527,0,0,0.25
23:39:39,1.025141,3277,redis-server,4,127.0.0.1,28527,127.0.0.1,48100,0,0,0.30
23:39:41,2.040949,7381,recordProgramSt,4,127.0.0.1,48102,127.0.0.1,28527,0,0,0.24
23:39:41,2.041011,3277,redis-server,4,127.0.0.1,28527,127.0.0.1,48102,0,0,0.29
23:39:42,3.067848,7404,recordProgramSt,4,127.0.0.1,48104,127.0.0.1,28527,0,0,0.30
23:39:42,3.067914,3277,redis-server,4,127.0.0.1,28527,127.0.0.1,48104,0,0,0.35
[...]
</code></pre><h2 id="端口过滤">端口过滤</h2>
<p>还有过滤本地/远端端口的选项. 这里就过滤了本地 22 和 80 端口.</p>
<pre tabindex="0"><code># ./tcplife.py -L 22,80
PID   COMM       LADDR           LPORT RADDR           RPORT TX_KB RX_KB MS
8301  sshd       100.66.3.172    22    100.127.64.230  58671     3     3 1448.52
[...]
</code></pre><h2 id="usage-说明">USAGE 说明</h2>
<pre tabindex="0"><code># ./tcplife.py -h
usage: tcplife.py [-h] [-T] [-t] [-w] [-s] [-p PID] [-L LOCALPORT]
                  [-D REMOTEPORT] [-4 | -6]

跟踪 TCP 会话的生命周期并进行总结

optional arguments:
  -h, --help            show this help message and exit
  -T, --time            include time column on output (HH:MM:SS)
  -t, --timestamp       include timestamp on output (seconds)
  -w, --wide            wide column output (fits IPv6 addresses)
  -s, --csv             comma separated values output
  -p PID, --pid PID     trace this PID only
  -L LOCALPORT, --localport LOCALPORT
                        comma-separated list of local ports to trace.
  -D REMOTEPORT, --remoteport REMOTEPORT
                        comma-separated list of remote ports to trace.
  -4, --ipv4            trace IPv4 family only
  -6, --ipv6            trace IPv6 family only

examples:
    ./tcplife           # trace all TCP connect()s
    ./tcplife -t        # include time column (HH:MM:SS)
    ./tcplife -w        # wider columns (fit IPv6)
    ./tcplife -stT      # csv output, with times &amp; timestamps
    ./tcplife -p 181    # only trace PID 181
    ./tcplife -L 80     # only trace local port 80
    ./tcplife -L 80,81  # only trace local ports 80 and 81
    ./tcplife -D 80     # only trace remote port 80
    ./tcplife -4        # only trace IPv4 family
    ./tcplife -6        # only trace IPv6 family
</code></pre></div>
    
  </div>
</div>


  </div>

  <div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="footer-inner">
          
          <ul class="social">
              
                  <li><a href="https://github.com/llaoj" target="blank"><img width="20" height="20" src="/social/github.svg" title="Github" alt="Github" /></a></li>
              
          </ul>
          
          <ul class="footer-menu">
            <li><a href="https://www.rutron.net/">Home</a></li>
            <li><a href="https://www.rutron.net/contact">Contact</a></li>
            <li class="copyright">© 2022 如创科技</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>
  <div class="sub-footer">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <div class="sub-footer-inner">
          <ul>
            
            <li><strong>Phone: </strong>15666139166</li>
            
            
            <li><strong>Email: </strong><a href="mailto:rutronnet@163.com">rutronnet@163.com</a></li>
            
          </ul>
          <ul>
            
            <li class="zerostatic"><a href="https://beian.miit.gov.cn/#/Integrated/index">鲁ICP备2021035257号-1</a></li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

  

  
  

  
  <script type="text/javascript" src="/js/scripts.min.98ee06cc35517b5800b382aecb0fc59893e95b9c11dd21842d0d57e4f68043e3.js"></script>
  

  
  
  
    
  


</body>
</html>
